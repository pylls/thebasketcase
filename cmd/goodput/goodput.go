/*
Package main implements a parser for a modified basket2proxy.log output
generated by github.com/pylls/basket2. The tool parses the file and computes
a number of stats on the goodput for the padding methods found in the log.
*/
package main

import (
	"bufio"
	"flag"
	"log"
	"math"
	"os"
	"strconv"
	"strings"

	"github.com/montanaflynn/stats"
)

func main() {
	flag.Parse()
	if len(flag.Args()) == 0 {
		log.Fatal("need to specify data dir")
	}

	resultsReceive := make(map[string][]float64)
	resultsTransmit := make(map[string][]float64)
	f, err := os.Open(flag.Arg(0))
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.Contains(line, "PaddingMethod:") &&
			strings.Contains(line, "Goodput") {
			// 0 -> basket2proxy:
			// 1 -> 2016/12/15
			// 2 -> 18:22:10
			// 3 -> [DEBUG]:
			// 4 -> [scrubbed]:47382:
			// 5 -> Receive:
			// 6 -> Total:
			// 7 -> 43142
			// 8 -> Overhead:
			// 9 -> 2960
			// 10 -> Payload:
			// 11 -> 22317
			// 12 -> Padding:
			// 13 -> 17865
			// 14 -> Goodput:
			// 15 -> 0.5172917342728663
			// 16 -> Trasmit:
			// 17 -> Total:
			// 18 -> 40810
			// 19 -> Overhead:
			// 20 -> 2800
			// 21 -> Payload:
			// 22 -> 19030
			// 23 -> Padding:
			// 24 -> 18980
			// 25 -> Goodput:
			// 26 -> 0.46630727762803237
			// 27 -> PaddingMethod:
			// 28 -> APE
			s := strings.Split(line, " ")
			if len(s) < 28 {
				log.Fatalf("too small PaddingMethod line, expected len() = %d, got %d",
					28, len(s))
			}
			v, err := strconv.ParseFloat(s[15], 64)
			if err != nil {
				log.Fatalf("failed to parse goodput (%s)", err)
			}
			if !math.IsNaN(v) && !math.IsInf(v, 1) && !math.IsInf(v, 0) {
				resultsReceive[s[28]] = append(resultsReceive[s[28]], v)
			}

			v, err = strconv.ParseFloat(s[26], 64)
			if err != nil {
				log.Fatalf("failed to parse goodput (%s)", err)
			}
			if !math.IsNaN(v) && !math.IsInf(v, 1) && !math.IsInf(v, 0) {
				resultsTransmit[s[28]] = append(resultsTransmit[s[28]], v)
			}
		}
	}

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}

	// compute stats
	for method := range resultsReceive {
		r := resultsReceive[method]
		t := resultsTransmit[method]
		rm, _ := stats.Mean(r)
		tm, _ := stats.Mean(t)
		rs, _ := stats.StandardDeviation(r)
		ts, _ := stats.StandardDeviation(t)
		rmed, _ := stats.Median(r)
		tmed, _ := stats.Median(t)

		log.Printf("%s, receive %.4f±%.4f %.4f, transmit %.4f±%.4f %.4f", method,
			rm, rs, rmed, tm, ts, tmed)
	}
}
